import sys
import os
from os import listdir
from os.path import isfile, join
import json
import array
import random
import tempfile
import subprocess

import lief

module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]

COMMON_SECTION_NAMES = open(os.path.join(
    module_path, 'section_names.txt'), 'r').read().rstrip().split('\n')
COMMON_IMPORTS = json.load(
    open(os.path.join(module_path, 'small_dll_imports.json'), 'r'))

#here is where we modify the malware
class ModifyBinary():
    def __init__(self, bytez):
        #setting malware file
        self.bytez = bytez
        #setting path to benign exes
        self.trusted_path = module_path + '/trusted/'
        #seting the path to benign txts (txt of benign exe)
        self.good_str_path = module_path + '/good_strings/'

    def _randomly_select_trusted_file(self):
        #pick a random trusted string if the trusted string dir
        return random.choice([
            join(self.trusted_path, f)
            for f in listdir(self.trusted_path)
            if (f != '.gitkeep') and (isfile(join(self.trusted_path, f)))
        ])

    def _randomly_select_good_strings(self):
        #pick a random .txt file from the good string dir (not git keep)
        good_strings = random.choice([
            join(self.good_str_path, f)
            for f in listdir(self.good_str_path)
            if (f != '.gitkeep') and (isfile(join(self.good_str_path, f)))
        ])
        #open and read the .txt
        with open(good_strings, 'r') as f:
            strings = f.read()
        #return the string of the benign txt
        return strings
    #return a random length of a power of 2
    def _random_length(self):
        #32, 64, 128, 256
        return 2**random.randint(5, 8)

    def _search_cave(self, name, body, file_offset, vaddr, cave_size=128, _bytes=b"\x00"):
        #list of found caves
        found_caves = []
        null_count = 0
        size = len(body)
        #loop through the size of the bosy
        for offset in range(size):
            #get that specific byte in the body
            byte = body[offset]
            check = False
            #if byte is not null set check to true
            if byte in _bytes:
                null_count += 1
            else:
                check = True
            #if our offset is at the very end
            if offset == size - 1:
                check = True
                offset += 1
            #we always check this at the very end
            if check:
                if null_count >= cave_size:
                    #set the cave start
                    cave_start = file_offset + offset - null_count
                    #set the cave end
                    cave_end = file_offset + offset
                    #set the cave size
                    cave_size = null_count
                    #append this cave to the found caves
                    found_caves.append([cave_start, cave_end, cave_size])
                null_count = 0
        #return the list of found caves
        return found_caves

    def _binary_to_bytez(self, binary, imports=False):
        # Write modified binary to disk
        builder = lief.PE.Builder(binary)
        builder.build_imports(imports)
        builder.build()
        #setting the modified binary is current binary
        self.bytez = array.array('B', builder.get_build()).tobytes()
        return self.bytez

    def rename_section(self):
        #turns the bytez list to a lief binary
        binary = lief.PE.parse(list(self.bytez))
        #chooses random section
        targeted_section = random.choice(binary.sections)
        #renames target section with a section name from a list of benign section names
        targeted_section.name = random.choice(COMMON_SECTION_NAMES)[:5]
        #sets bytez to modified bytez
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def add_bytes_to_section_cave(self):
        #empty cave list
        caves = []
        #set bytez to lief binry
        binary = lief.PE.parse(list(self.bytez))
        #get base address of our binary
        base_addr = binary.optional_header.imagebase
        #go through sections of the malware
        for section in binary.sections:
            #set section offset
            section_offset = section.pointerto_raw_data
            #set vaddr to be virtual addr + base addr
            vaddr = section.virtual_address + base_addr
            #set the body to the the section content
            body = section.content
            #if the raw data size is larger than the virtual size
            if section.sizeof_raw_data > section.virtual_size:
                #add dif of raw and virtual of b"\x00" to the end of our body
                body.extend(list(b"\x00" * (section.sizeof_raw_data - section.virtual_size)))
            #get a list of our caves 
            caves.extend(self._search_cave(section.name, body, section_offset, vaddr))

        if caves:
            #if caves exist then we choose a random cave
            random_selected_cave = random.choice(caves)
            #get a random byte
            upper = random.randrange(256)
            #array of random bytes
            add_bytes = bytearray([random.randint(0, upper) for _ in range(random_selected_cave[-1])])
            #replace cave with random bytes
            self.bytez = self.bytez[:random_selected_cave[0]] + add_bytes + self.bytez[random_selected_cave[1]:]

        return self.bytez
    #changes the machine type of the binary to one of four from a list of machine types
    def modify_machine_type(self):
        binary = lief.PE.parse(list(self.bytez))
        binary.header.machine = random.choice([
            lief.PE.MACHINE_TYPES.AMD64,
            lief.PE.MACHINE_TYPES.IA64,
            lief.PE.MACHINE_TYPES.ARM64,
            lief.PE.MACHINE_TYPES.POWERPC])

        self.bytez = self._binary_to_bytez(binary)

        return self.bytez
    #Modifies the header timestamp
    def modify_timestamp(self):
        #bytez to lief binary
        binary = lief.PE.parse(list(self.bytez))
        #sets the timestamp in the reader to a random value
        binary.header.time_date_stamps = random.choice([
            0, 868967292, 993636360, 587902357, 872078556
        ])
        #set the bytez to be the modified bytez
        self.bytez = self._binary_to_bytez(binary)

        return self.bytez
    #append random 100 kilobytes to the end of our malware 
    def pad_overlay(self):
        byte_pattern = random.choice([i for i in range(256)])
        overlay = bytearray([byte_pattern] * 100000)
        self.bytez += overlay

        return self.bytez

    def append_benign_data_overlay(self):
        #retrieve random benign file
        random_benign_file = self._randomly_select_trusted_file()
        #turn random benign file to a lief binary
        benign_binary = lief.PE.parse(random_benign_file)
        #get section content of benign binary
        benign_binary_section_content = benign_binary.get_section('.text').content
        #set overlay to be byte array of text content of benign exe
        overlay = bytearray(benign_binary_section_content)
        #add overlay to our malware
        self.bytez += overlay

        return self.bytez

    def append_benign_binary_overlay(self):
        #retrienve random benign file
        random_benign_file = self._randomly_select_trusted_file()
        #read the entire file
        with open(random_benign_file, 'rb') as f:
            benign_binary = f.read()
        #add the entire benign binary to the end of the malware
        self.bytez += benign_binary

        return self.bytez

    def add_section_benign_data(self):
        #retrienve random file
        random_benign_file = self._randomly_select_trusted_file()
        #turn our benign binary into an lief binary
        benign_binary = lief.PE.parse(random_benign_file)
        #get section content of benign binary
        benign_binary_section_content = benign_binary.get_section('.text').content
        #turn our malware into an lief binary
        binary = lief.PE.parse(list(self.bytez))
        #get a list of the sections in our malware
        current_section_names = [section.name for section in binary.sections]
        #get a list of benign section names that are not already in the malware
        available_section_names = list(set(COMMON_SECTION_NAMES) - set(current_section_names))
        #init a new PE section with an unused section name
        section = lief.PE.Section(random.choice(available_section_names))
        #add our benign data to our empty section
        section.content = benign_binary_section_content
        #add our new section to our malware
        binary.add_section(section, lief.PE.SECTION_TYPES.DATA)
        #set the bytez to the modified bytez
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def add_section_strings(self):
        #retrieve a random benign PE string
        good_strings = self._randomly_select_good_strings()
        #set our malware to a lief binary
        binary = lief.PE.parse(list(self.bytez))
        #get a list of the sections in our malware
        current_section_names = [section.name for section in binary.sections]
        #get a list of benign section names that are not already in the malware
        available_section_names = list(set(COMMON_SECTION_NAMES) - set(current_section_names))
        #init a new PE section with an unused section name
        section = lief.PE.Section(random.choice(available_section_names))
        #set the section content to be benign data from our good string
        section.content = [ord(c) for c in good_strings]
        #add our benign section to our malware
        binary.add_section(section, lief.PE.SECTION_TYPES.DATA)
        #set bytez to the modified bytez
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def add_strings_to_overlay(self):
        """
        Open a txt file of strings from low scoring binaries.
        https://skylightcyber.com/2019/07/18/cylance-i-kill-you/
        """
        #retriev a random good string
        good_strings = self._randomly_select_good_strings()
        #append good string to the end of our malware
        self.bytez += bytes(good_strings, encoding='ascii')

        return self.bytez

    def add_imports(self):
        #bytez to lief binary
        binary = lief.PE.parse(list(self.bytez))

        # draw a library at random
        libname = random.choice(list(COMMON_IMPORTS.keys()))
        funcname = random.choice(list(COMMON_IMPORTS[libname]))
        lowerlibname = libname.lower()
        """adds a new library, ofc we must ensure it does not already exist"""
        # find this lib in the imports, if it exists
        lib = None
        for im in binary.imports:
            if im.name.lower() == lowerlibname:
                lib = im
                break

        if lib is None:
            # add a new library if DNE
            lib = binary.add_library(libname)

        # get current names
        names = set([e.name for e in lib.entries])
        if funcname not in names:
            #add new funcname if function DNE
            lib.add_entry(funcname)
        #set bytez to modified bytez
        self.bytez = self._binary_to_bytez(binary, imports=True)

        return self.bytez

    def remove_debug(self):
        #bytez to lief binary
        binary = lief.PE.parse(list(self.bytez))
        
        if binary.has_debug:
            #look for the PE dir debug, if we find it we delete it
            for i, e in enumerate(binary.data_directories):
                if e.type == lief.PE.DATA_DIRECTORY.DEBUG:
                    e.rva = 0
                    e.size = 0
                    #set bytez to modified bytez
                    self.bytez = self._binary_to_bytez(binary)
                    return self.bytez
        # no debug found
        return self.bytez

    def modify_optional_header(self):
        #set bytez to lief binary
        binary = lief.PE.parse(list(self.bytez))
        #dict of optional headers
        oh = {
            "major_linker_version": [2, 6, 7, 9, 11, 14],
            "minor_linker_version": [0, 16, 20, 22, 25],
            "major_operating_system_version": [4, 5, 6, 10],
            "minor_operating_system_version": [0, 1, 3],
            "major_image_version": [0, 1, 5, 6, 10],
            "minor_image_version": [0, 1, 3]
        }
        #retrieve a random optional header
        key = random.choice(list(oh.keys()))
        #get a random val from our list
        modified_val = random.choice(oh[key])
        #sett optional header key and val to be retrieved values
        binary.optional_header.__setattr__(key, modified_val)
        #set bytez to modified bytez
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez

    def break_optional_header_checksum(self):
        #set bytez to lief bianry
        binary = lief.PE.parse(list(self.bytez))
        #set checksum to 0 (break it)
        binary.optional_header.checksum = 0
        #set bytez to modified bytez
        self.bytez = self._binary_to_bytez(binary)
        return self.bytez
    """uses upx to unpack the binary"""
    def upx_unpack(self):
        # dump bytez to a temporary file
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))
        #write bytez to tmpfile
        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)
        
        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ['upx', tmpfilename, '-d', '-o', tmpfilename + '_unpacked'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # sucessfully unpacked
            with open(tmpfilename + '_unpacked', 'rb') as result:
                self.bytez = result.read()

            os.unlink(tmpfilename + '_unpacked')
            
        return self.bytez
    """uses upx to pack the binary"""
    def upx_pack(self):
        # tested with UPX 3.94
        # WARNING: upx compression only works on binaries over 100KB
        tmpfilename = os.path.join(
            tempfile._get_default_tempdir(), next(tempfile._get_candidate_names()))

        # dump bytez to a temporary file
        with open(tmpfilename, 'wb') as outfile:
            outfile.write(self.bytez)

        options = ['--force', '--overlay=copy']
        compression_level = random.randint(1, 9)
        options += ['-{}'.format(compression_level)]
        options += ['--compress-exports={}'.format(random.randint(0, 1))]
        options += ['--compress-icons={}'.format(random.randint(0, 3))]
        options += ['--compress-resources={}'.format(random.randint(0, 1))]
        options += ['--strip-relocs={}'.format(random.randint(0, 1))]

        with open(os.devnull, 'w') as DEVNULL:
            retcode = subprocess.call(
                ['upx'] + options + [tmpfilename, '-o', tmpfilename + '_packed'], stdout=DEVNULL, stderr=DEVNULL)

        os.unlink(tmpfilename)

        if retcode == 0:  # successfully packed

            with open(tmpfilename + '_packed', 'rb') as infile:
                self.bytez = infile.read()

            os.unlink(tmpfilename + '_packed')

        return self.bytez

#modify a malware sanmple
def modify_sample(bytez, action):
    bytez = ModifyBinary(bytez).__getattribute__(action)()
    return bytez

#our table of modifications
ACTION_TABLE = {
    'modify_machine_type': 'modify_machine_type',
    'pad_overlay': 'pad_overlay',
    'append_benign_data_overlay': 'append_benign_data_overlay',
    'append_benign_binary_overlay': 'append_benign_binary_overlay',
    'add_bytes_to_section_cave': 'add_bytes_to_section_cave',
    'add_section_strings': 'add_section_strings',
    'add_section_benign_data': 'add_section_benign_data',
    'add_strings_to_overlay': 'add_strings_to_overlay',
    'add_imports': 'add_imports',
    'rename_section': 'rename_section',
    'remove_debug': 'remove_debug',
    'modify_optional_header': 'modify_optional_header',
    'modify_timestamp': 'modify_timestamp',
    'break_optional_header_checksum': 'break_optional_header_checksum',
    'upx_unpack': 'upx_unpack',
    'upx_pack': 'upx_pack'
}

if __name__ == "__main__":
    # use for testing/debugging actions
    import hashlib
    from IPython import embed

    # filename =  '../utils/samples/e090668cfbbe44474cc979f09c1efe82a644a351c5b1a2e16009be273118e053' # upx packed sample
    filename = '../utils/samples/7a5d1bb166c07ed101f2ee9cb43b3a8ce0d90d52788a0d9791a040d2cdcc8057'
    with open(filename, 'rb') as f:
        bytez = f.read()

    m = hashlib.sha256()
    m.update(bytez)
    print("original hash: {}".format(m.hexdigest()))

    action = 'upx_pack'
    bytez = modify_sample(bytez, action)

    m = hashlib.sha256()
    m.update(bytez)
    print("modified hash: {}".format(m.hexdigest()))

    embed()
