#!/usr/bin/python
'''
Defines the MalConv architecture.
Adapted from https://arxiv.org/pdf/1710.09435.pdf
Things different about our implementation and that of the original paper:
 * The paper uses batch_size = 256 and
   SGD(lr=0.01, momentum=0.9, decay=UNDISCLOSED, nesterov=True )
 * The paper didn't have a special EOF symbol
 * The paper allowed for up to 2MB malware sizes,
   we use 1.0MB because of memory on a Titan X
 '''
import os
import sys
from keras import metrics
from keras.optimizers import SGD
from keras.models import load_model
import numpy as np
import tensorflow as tf
from pathlib import Path
#define mod path
module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
#add malconv model to modpath
model_path = os.path.join(module_path, 'malconv.h5')
#set the verbosity
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

model_path_uptrain = os.path.join(module_path, 'malconv_uptrained.h5')

#our malconv class
class MalConv():
    #init function
    def __init__(self):
        #params of our network, see malconv repo for model training
        self.batch_size = 100
        self.input_dim = 257  # every byte plus a special padding symbol
        self.padding_char = 256
        self.malicious_threshold = 0.5
        #load our trained model with the our params
        self.model = load_model(model_path)
        _, self.maxlen, self.embedding_size = self.model.layers[1].output_shape
        #compile the model, ready for testing!
        self.model.compile(
            loss='binary_crossentropy',
            optimizer=SGD(lr=0.01, momentum=0.9, nesterov=True, decay=1e-3),
            metrics=[metrics.binary_accuracy]
        )

    def extract(self, bytez):
        #list that is max length filled with padding char
        b = np.ones((self.maxlen,), dtype=np.int16) * self.padding_char
        #loading our malware file
        bytez = list(bytez)
        #making malware as long as max length
        bytez = np.array(bytez[:self.maxlen])
        #adding padding char to the end bytez list
        b[:len(bytez)] = bytez
        #return our padded malware
        return b

    def predict_sample(self, bytez):
        #predict incoming malware sample
        return self.model.predict(bytez.reshape(1, -1))[0][0]
    
    def uptrain_model(self, bytez, agent):
        # samples: nested list of integers
        # labels: list of integeters
        #samples = [self.extract(s) for s in samples]
        print("fitting")
        model_name = agent + '_uptrained.h5'
        self.model.fit(x = bytez.reshape(1, -1), y = np.array([1]), epochs = 1)
        parent_dir = str(Path(model_path_uptrain).parent)
        if not os.path.exists(parent_dir):
            os.makedirs(parent_dir)
        self.model.save(model_path_uptrain)
