import os
import sys
import random
import hashlib
from collections import OrderedDict
import numpy as np
import gym
from gym import spaces
#go and get interface and malconv
from h4rm0ny.envs.utils import interface, malconv
#go and get modifiers
from h4rm0ny.envs.controls import modifier
#set seed for reproducability 
random.seed(0)
#get module path
module_path = os.path.split(os.path.abspath(sys.modules[__name__].__file__))[0]
#i is index of action, act is action 
ACTION_LOOKUP = {
    i: act for i, act in enumerate(modifier.ACTION_TABLE.keys())
}
#malconv model
mc = malconv.MalConv()
#mal thresh (0.5)
malicious_threshold = mc.malicious_threshold


class MalConvEnv(gym.Env):
    """Create MalConv gym interface"""
    metadata = {'render.modes': ['human']}

    def __init__(self, sha256list, random_sample=True, maxturns=5, output_path='data/evaded/malconv_ember', uptrain = False, agent="acer"):
        super(MalConvEnv, self).__init__()
        #list of malware for gym
        self.available_sha256 = sha256list
        #action space for gym
        # Discrete variable that can take len(ACTION_LOOKUP) possible values 
        self.action_space = spaces.Discrete(len(ACTION_LOOKUP))
        #observation space (size of malware)
        self.observation_space = spaces.Box(low=0, high=256, shape=(1048576,), dtype=np.int16)
        #max number of turns
        self.maxturns = maxturns
        #feature extractor is our just reading the malware and padding if needed
        self.feature_extractor = mc.extract
        #where we put evading malware
        self.output_path = output_path
        #bool param for random sample
        self.random_sample = random_sample
        #our history is an ordered dictionary
        self.history = OrderedDict()
        #start sample iter index at 0
        self.sample_iteration_index = 0
        self.uptrain = uptrain
        #output path again
        self.output_path = os.path.join(
            os.path.dirname(
                os.path.dirname(
                    os.path.dirname(
                        os.path.abspath(__file__)))), output_path)
        
        self.bytez_history = []
        self.agent = agent
    #step function
    def step(self, action_ix):
        # Execute one time step within the environment
        #turns defined in reset(), starts at 0
        self.turns += 1
        #modify the malware with action 'action_ix'
        self._take_action(action_ix)
        #turn the obfuscated malware file into something readable by malconv and set our observation space to the malware
        self.observation_space = self.feature_extractor(self.bytez)
        #predict the malware 
        self.score = mc.predict_sample(self.observation_space)
        #print("The probability that this file is malicious is {}".format(self.score))
        #if our malware is classified as benignware
        if self.score < malicious_threshold:
            #set our reward to 10
            reward = 1 - self.score
            #end the episode
            episode_over = True
            #record that the malware was evasive
            self.history[self.sha256]['evaded'] = True
            #record the reward the malware received 
            self.history[self.sha256]['reward'] = reward

            # save off file to evasion directory
            m = hashlib.sha256()
            m.update(self.bytez)
            sha256 = m.hexdigest()
            evade_path = os.path.join(self.output_path, sha256)

            with open(evade_path, 'wb') as out:
                out.write(self.bytez)
                
            #self.bytez_history.append(self.bytez)
            """This is where we uptrain"""
            if self.uptrain:
                mc.uptrain_model(self.feature_extractor(self.bytez),self.agent )
            
            self.history[self.sha256]['evade_path'] = evade_path
        #our malware has been detected and we have tried too many times
        elif self.turns >= self.maxturns:
            # game over - max turns hit
            #original score defined in reset(), it is the malwares original prediction score
            reward = self.original_score - self.score
            #end the episode
            episode_over = True
            #record that the malware failed to be evasive
            self.history[self.sha256]['evaded'] = False
            #record the reward the malware received
            self.history[self.sha256]['reward'] = reward
        #malware was not evasive but we still have turns left
        else:
            #reward for this action
            reward = float(self.original_score - self.score)
            #episode is not over
            episode_over = False
        
        #% steven
        #% mc.train([xxx])
        if episode_over:
            print('Episode over: reward = {}, episodes taken = {}'.format(reward, self.turns))

        return self.observation_space, reward, episode_over, self.history[self.sha256]

    def _take_action(self, action_ix):
        #go find action in dict
        action = ACTION_LOOKUP[action_ix]
        # print("ACTION:", action)
        #record this action taking place in the history of that malware
        self.history[self.sha256]['actions'].append(action)
        #modify the malware. look to /controls/modifier.py

        self.bytez = modifier.modify_sample(self.bytez, action)

    def reset(self):
        # Reset the state of the environment to an initial state
        self.turns = 0
        while True:
            # grab a new sample (TODO)
            #go get a random malware sample
            if self.random_sample:
                self.sha256 = random.choice(self.available_sha256)
            #go get the next piece of malware in the list
            else:
                self.sha256 = self.available_sha256[
                    self.sample_iteration_index % len(self.available_sha256)
                ]
                self.sample_iteration_index += 1
            #setup a history of the malware we will work with
            self.history[self.sha256] = {'actions': [], 'evaded': False}
            #read the malware file
            self.bytez = interface.fetch_file(self.sha256)
            #set the observation space to something malconv can read
            self.observation_space = self.feature_extractor(self.bytez)
            #predict the malware with no obfuscations
            self.original_score = mc.predict_sample(self.observation_space)
            #check if malware can be skipped
            if self.original_score < malicious_threshold:
                # already labeled benign, skip
                continue

            break
        print('Sample: {}'.format(self.sha256))
        #return the malware in a state than can be read by malconv 
        return self.observation_space

    def render(self, mode='human', close=False):
        # Render the environment to the screen
        pass
